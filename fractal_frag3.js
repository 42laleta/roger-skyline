let fragShader_str =
["uniform vec2 iResolution;",
"uniform float iTime;",
"uniform vec2 iMouse;",
"vec3 rotate(vec3 p, float angleX, float angleY)",
"{",
    "float cosA = cos(angleY);",
	"float sinA = sin(angleY);",
	"vec3 r = vec3(p.x, sinA * p.z + cosA * p.y, cosA * p.z - sinA * p.y);",
    "cosA = cos(angleX);",
	"sinA = sin(angleX);",
	"return (-vec3(cosA * r.x - sinA * r.z, r.y, sinA * r.x + cosA * r.z));",
"}",
"vec3 hsv2rgb(vec3 c)",
"{",
    "vec3 rgb = clamp(abs(mod(c.x * 6.0 + vec3(0.0,4.0,2.0),6.0) - 3.0) - 1.0, 0.0, 1.0);",
	"return (c.z * mix(vec3(1.0), rgb, c.y));",
"}",
"float distSphere(vec3 p, float r)",
"{",
	"return (length(p) - r);",
"}",
"float sierpinski(vec3 p)",
"{",
    "const int iter_cnt = 20;",
    "float scale = clamp(sin((iTime - 7.0) * 0.2) + 2.02, 1.0, 2.0);",
    "float offset = 1.0;",
    "for (int n = 0; n < iter_cnt; n++)",
    "{",
       "if(p.x + p.y < 0.0) p.xy = -p.yx;",
       "if(p.x + p.z < 0.0) p.xz = -p.zx;",
       "if(p.y + p.z < 0.0) p.zy = -p.yz;",	
       "p = p * scale - offset * (scale - 1.0);",
    "}",
    "return (length(p)) * pow(scale, -float(iter_cnt));",
"}",
"float distPlane(vec3 p, vec4 n)",
"{",
	"return (dot(p, n.xyz) + n.w);",
"}",
"bool bgS = false;",
"bool bgP = false;",
"float distanceEstimate(vec3 p)",
"{",
	"float dSphere = -distSphere(p, 30.0);",	
	"float dFractal = sierpinski(p);",
    "float dPlane = distPlane(p, normalize(vec4(-10.0, -10.0, 10.0, 10.1)));",
    "bgP = dPlane < dFractal ? true : false;",
    "bgS = dSphere < dPlane ? true : false;",
	"return (min(min(dFractal, dPlane), dSphere));",
"}",
"vec3 getNormal(vec3 pos, float dist)",
"{",
    "vec3 eps = vec3(0.001, 0.0, 0.0);",
	"return normalize(vec3(distanceEstimate(pos + eps.xyy), distanceEstimate(pos + eps.yxy),distanceEstimate(pos + eps.yyx)) - dist);",
"}",
"float softShadow(in vec3 ro, in vec3 rd, in float k)",
"{",
    "float res = 1.0;",
    "float t = 0.0;",
    "for(int i = 0; i < 64; i++)",
    "{",
        "float d = distanceEstimate(ro + rd * t);",
        "res = min(res, k * d/t);",
        "if(res < 0.001)",
            "break;",
        "t += clamp(d, 0.01, 0.2);",
    "}",
    "return (clamp(res, 0.0, 1.0));",
"}",
"void main()",
"{",
	"vec2 aspectRatio = vec2(iResolution.x/iResolution.y, 1.0);",
	"vec2 uv = aspectRatio * (gl_FragCoord.xy / iResolution.xy - 0.5);",
    "vec2 mouse = 4.0 * (iMouse.xy / iResolution.xy - 0.5);",
    "mouse.x += 2.7;",
    "mouse.y -= 0.4;",
    "vec3 ro = rotate(vec3(0.0, -0.1, sin((iTime - 7.0) * 0.2) + 2.5), mouse.x, mouse.y);",
    "vec3 rd = -rotate(vec3(uv, 1.0), mouse.x, mouse.y);",
    "vec3 light = rotate(vec3(0.7, -0.22, 0.5), mouse.x, mouse.y);",
    "vec3 lightColor = vec3(0.9, 1.0, 1.0);",
    "vec3 material;",
    "vec3 color;",
    "float eps = 0.002;",
	"float dist;",
	"for(float n = 0.0; n < 200.0; n++)",
    "{",
		"dist = distanceEstimate(ro);",
		"if(dist < eps)",
			"break;",
		"ro += rd * dist * 0.5;",
	"}",
	"if(bgS == true)",
	"{",
        "color = vec3(1.0, 1.0, 0.5) * (1.0 + 0.9 * uv.y);",
		"gl_FragColor = vec4(color, 1.0);",
		"return;",
	"}",
    "if(bgP == true)",
        "material = hsv2rgb(vec3(dot(ro, ro) * 0.0001 + 0.52, ro.y, 0.4));",
    "else",
        "material = hsv2rgb(vec3(dot(ro, ro) * 0.11 + 0.62, 0.98, 1.2));",
	"vec3 norm = getNormal(ro, dist);",
	"vec3 lightDir = normalize(light - rd);",
	"float shadow = softShadow(ro + 0.001 * norm, light, 20.0);",
    "float ambient = 0.5;",
	"float diff = clamp(dot(light, norm), 0.0, 1.0) * shadow * 2.5;",
	"float spec = pow(clamp(dot(norm, lightDir), 0.0, 1.0), 32.0) * shadow * 2.0;",
 	"color = (lightColor * (ambient + diff + spec) * material);",   
    "color = pow(color, 0.9 * lightColor);",
    "gl_FragColor = vec4(color, 1.0);",
"}"].join("\n");
